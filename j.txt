## J

https://www.youtube.com/watch?v=BGTx91t8q50
. Programming languages -> 1. Functional 2.Procedural 3.OOP
. Static and Dynamic typed languages.
. In Static Typing, type checking is performed during compile time. It means that the type of a variable is known at compile time.(java,C,C++)
. In Dynamic Typing, type checking is performed at runtime. For example, Python is a dynamically typed language. It means that the type of a variable is allowed to change over its lifetime.(python, php, js, Ruby).
. java works on unicode languages supports every regional language.
. instance variable is defined in class and can be accessed through out the class and local variable is defined in mthd.
. instance var,obj-- in heap memory, local var,ref var-- in stack memory.
. var in stack memory and each obj in heap memory with address. memory in jvm. main stack, new mthd abc- abc stack memory. Each mthd will have it's own stack in the jvm.


. platform indipendent - run application on any machine irrespective of h/w or OS but machine must have jvm.
			app is indipendent but jvm is dependent every os has its own jvm.
			jvm looks for the main method to start the execution.(execution starts from the main method.)
. Programmer writes Java code(Source code .java file), which is compiled(using javac compiler) to Byte code(.class file) which is understood by the JVM.

. To run the code javac Hello.java then java Hello OR can simply do in one step java Hello.java
. h/w->os->jdk(->jre(->jvm))
. code will run on jvm, jre has required libs to run the code.(inbuilt libs classes used in the code.) also validate the byte code, class loader.
. Compile code with jdk and run on jvm. jre has necessary lib,fles, class req to run byte code

. The Just-In-Time (JIT) compiler is a component of the runtime environment that improves the performance of Java applications     by compiling bytecodes to native machine code at run time.

. java is compiler-interpreter lang. .java file is compiled/transformed using the javac compiler into the bytecode which is understood by the jvm. The jvm then interprets this bytecode and converts it into the machine code which can be understood by the computers h/w.

. The source code we write in Java is first compiled into bytecode during the build process. The JVM then interprets the generated bytecode for execution. However, the JVM also makes use of a JIT compiler during runtime to improve performances.

. var is a reserved type name, detects variable data type automatically.

. java is strongly typed language.
. In java there is no pass by referance, there is only pass by value.
. Shadowing in java.
. Shadowing in Java is the practice of using variables in overlapping scopes with the same name where the variable in low-level scope overrides the variable of high-level 
  scope.
. Declaration at compile time and initilisation at run time(i.e obj in heap) int a(at compile time)=10;(at run time) -> Dynamic memory allocation.

. Enhanced for loop for arrays.

. reference var/obj ref.	 Calculator(type) c(ref var) = new Calculator() 

. public -> accessible everywhere in the project.
  private -> accessible in the same class, no one from outside world can access the data directly.
  default -> accessible in the same package.//i.e acc in same class, package subclass, package non-subclass.
  protected -> accessible in same package and subclass of diff package.// accessible in same class, package subclass, package non-subclass, diff package subclass.

. class public, instance var private, mthd public. rest requirement based. avoid default.
. varargs ambiguity while mthd overloading. //compiler cannot decide which mthd to call.		public void Name(String... n){for(String i:n){Syso(i + " ");}}

Method overloading
. same mthd name different parameters. either parameter length or type should be different. 

Stack and heap memory in jvm
. stack lifo and heap open space expandable.
. every mthd has its own stack.


* SOLID Principles Java
. In Java, SOLID principles are an object-oriented approach that are applied to software structure design.  It also ensures that the software is modular, easy to 
  understand, debug, and refactor.
. The word SOLID acronym for:
	|-> Single Responsibility Principle (SRP) -> The single responsibility principle states that every Java class must perform a single functionality.

	|-> Open-Closed Principle(OCP) -> The open-closed principle states that according to new requirements the module should be open for extension but closed for modification.
	|-> Liskov Substitution Principle (LSP) -> It applies to inheritance in such a way that the derived classes must be completely substitutable for their base classes.

	|-> Interface Segregation Principle (ISP) -> The principle states that the larger interfaces split into smaller ones. Because the implementation classes use only the methods that are required.
	|-> Dependency Inversion Principle (DIP) -> The principle states that we must use abstraction (abstract classes and interfaces) instead of concrete implementations.



* How function calls work.
. while the function has not stopped executing it will remain in the stack.
. when a function finishes execution it is removed from the stack and the flo3w of the program is restored to where it was called.
. main function is the last function to be removed from the stack. (and first to be added.)
https://www.youtube.com/watch?v=M2uO2nMT0Bk&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=23


* Recursion
. method calling itself.
. if you are calling a function again and again you can treat as an separate call in the stack.
. Base condition is the condition where our recursion will stop making new calls. (simole if condition.)
. Helps in solving big/complex problems easily.
. recursion tree is the flow of the mthd calls.
. last function call is called tail recursion.


* Array objects are in heap and heap objects are not continuous due to dynamic memory allocation. So in java it is not compulsory always that memory allocation done in continuous sequence it is depend on J.V.M.

Switch
. switch supports int, char, byte, short, and String (Java 7+).
. It does not support long, float, double, boolean, or general objects.

Arrays								  datatype ref.var.=object;
. arrays are objects, can hold multiple values of same data type. int a[]={1,2,3}; or int a[] = new int[3]; a[0]=1;
. multidimetional array is array of arrays. int a[][] = new int[3][4]; to assign random values a[i][j] = (int)(Math.random()*10);
. 2 for loops 1 for row and other for column.
. enhanced for loop. no need of array length. for(int n[]:a){for(int m:n){syso(m);}sysoln(" ");}  
. jagged array int a[][] = new int[3][];				for(int i=0;i<a.length;i++){		FOR JAGGED ARRAY.
		a[0]=new int[3]; defining column size.				for(int j=0;j<a[i].length;j++{
		a[1]=new int[2];							Syso(a[i][j]);}
		a[2]=new int[4];						Sysoln("");}
. drawback size fixed, will traverse the array to find element time consuming.
. Array of objects. Student stud[] = new Student[3];			Student s1=new Student();
			stud[0]=s1  (ref var of Student)		s1.rollno=3;
. In ArrayList initially size is fixed but when limit reaches, it copies the elements to new list with increased size and deletes the prev. list.

** Command line arguments in java  (String[] args);



== vs .equals. (== is a comparator)
. == operator to check memory location or address of two objects are the same or not.
. == checks if both objects point to the same memory location whereas .equals() evaluates to the comparison of values in the objects.



String									   Datatype  ref.var. = object;		|  b |	--------(---	)    point to same object in string
. String is a class in java. String s=new String("abc"); syso(s);		* String a = "Rana";		|  a | ---------( "Rana")    pool in heap memory.	
. String has different mthds s.charAt,						* String b = "Rana"		|____|		(	)
														stack		   heap
. If 2 strings have same content(value) they get same address in string constant pool. strings are immutable. 			
. String pool is separate memory structure in the heap memory(created for optimisation) if n no. of ref var have same value, they point to one obj.
. If we change something in the existing string, it creates new constant.
. Can create different string objects with same value using 'new' explicitly. The object will be created in the heap memory outside string pool.
e.g.    String a="ab"; address 101  constant, immutable
	a=a+"cd";	address 102
Syso()		println -> is of type printStream -> has mthd valueOf -> which uses toString.	****//CHECK.
 . pretty printing in java using printf.
eg :- System.out.prinf("My name is %s and i am %s", "Abcd", "happy."); output -> My name is Abcd and iam happy. 	//format specifier.
. if printing an object it will call toString().
. + operator works for primitives and in an expression atleat in eshould be an string (new ArrayList<>() + "" + new Integer(21)) output -> []21  //without string("") error.




String s
. s.split(regex) -split in array- if regex =" " , split after every space.
. s.trim()  removes starting and ending spaces.
. s.replaceAll(regex,replacement)
. s.replace()
. .comparesTo--- if s1>s2 +ve val,s1==s2 0,s1<s2 -ve value; 
.valueOf  int to string.
. Strings are immutable, string constant pool
String, buffer, builder.
. StringBuffer is a class in Java that represents a mutable sequence of characters. It provides an alternative to the immutable String class, allowing you to modify the contents of a string without creating a new object every time.
StringBuffer is thread safe and StringBuilder is not.



StringBuilder sb
. sb.charAt
. sb.setCharAt
. sb.insert
. sb.delete
. sb.append
. sb.length
. sb.replace
. sb.reverse
. sb.toString


Static		//no need to create obj of class to use the static variable, can be called using classname psvm()
. static variable makes the variable common to all the objs i.e static var is shared by all the objs.
. static var/mthd should be called with the class names instead of the objs.
. dont need object of class to call static mthd.
. The main() method is static so that JVM can invoke it without instantiating the class.
. static makes something a class member not obj member.
. can use static variable in a non static mthd.
// not neccess. static method can only call a static method. in same class.
. static block used to initialise the static variables.
. static block is called only once irrespective of how many objs are created.
. class loads and then obj is instantiated, and class loads only once (via class loader).every time class loads it will call static block.
. static block call---> then const.(if no obj creation then class don't load, then to call static block Class.forName(className))
. cannot access non static var in a static method but can access static var in static method and non static mthd.
	each object has its own value. obj.name="abc"; obj1.name="def"; 
. can use non static var in a static mthd by passing the obj itself in the static method. (which obj value u want to show Classname.statmthd(obj1))
. cannot access non static variables in a static mtd.


Encapsulation
. binding of data with methods. getter setter. create instance variables as private an use get set mthds.


This Keyword
. The this keyword refers to the current object in a method or constructor which is callig the mthd. eg in main mthd class A i am calling a mthd from other class B.(both instance and local variable have same name.)

public void setName(String name){
		this.name=name;}
obj.setName("we");	//in main mthd.

. priority given to the local var
. private name;
. public void setName(String name){
. this.name=name; // this.name is instance var and name is local variable. bts classname obj1=obj(obj passed in mthd); /n obj1.name=name;


Constructors
. same name as that of a class, has no return type.
. Can give default values to variables. //otherwise default values are 0, null.
. called when an obj is created. // default constuctor, parameterised const.
. ** super()--execute the const of super class. john cena cant see it its there.(inheritance) create obj of subclass, constructor of super class will also be called.
. if using super(), then default constructor will be called of parent/super class. if want to call other constructor than the default then add parameter to super mthd.(i.e match the signature with paramterized const in super class) 
. this()--execute the const of same class and super()--executes the const of super class. if parameters are empty then default const will be called.

class A
{
	  public A()
	{	Syso("in default A const");	}
	  public A(int i)
	{	Syso("in param A const";	}
}
class B extends A
{
	  public B()
	{	Syso("in default B const");	}	//super is automatically there.
	  public B(int i)
	{	Syso("in param B const";	}
}
in main mthd	{
B obj = new B();	//output -> in default A const  (then) in defaukt const B

for more watch https://www.youtube.com/watch?v=BGTx91t8q50

..singleton class. class which can have only one global object.


Anonymous object
. has no refrence var. // new ClassName(); will call const only, new ClassName().methodname(); will call mthd also, can't be used again.
. has no name.


Inheritance
. single level multi level inheritance // parent/super/base class  child/sub/derived class
. java does not support multiple inheritance //ambiguity
. when we create a Child class object and call the method a() which is present in both parent1 and parent2, the compiler gets confused about whether to call the a() method of Parent1 or Parent2. This is the ambiguity problem faced by the compiler hence multiple inheritance is not supported in Java.
. every class which does not extends, extends the Object class by default


Method Overriding
. same name method in subclass can override method in the parent class. if want other mthd of parent class but not want implementation of mthd eg a() and want diff implementation for it then declare that mthd in child class and create the obj of child class. this will override the a() mthd and other required mthds of parent class can be used.
. private, static, final methods cannot be overriden. (static -> method hiding, hides superclass mthd.)
. Like C++, when a function is static(parent), runtime polymorphism doesn\'t happen.

packages
. import class which is in different package.
. java.lang package imported by default. when we use system,string etc it is from java.lang package 


Polymorhism (many forms/behaviour)
. Compile time polymorhism (early binding) -->mthd overloading // behaviour defined at compile time. static polymorphism.
. Run time polymorhism (late binding) -->mthd overriding , dynamic method dispatch(refrence of parent and obj of child).jvm Dynamic polymorphism


WRAPPER class (to make entirely object oriented)
. java is not entirely Object oriented. because of primitive data types don't extend Object class.
. for every primitive type we have a class which is used in certain frameworks.
. storing primitive variable in wrapper class object is called autoboxing. int a=4; Integer b=a;	//Autoboxing.
. integer b=a; int c =b; //auto-unboxing  or int c= b.intValue(); //unboxing.


Dynamic Method Dispatch (impliments run time polymorphism)
. at run-time, it depends on the type of the object being referred to (not the type of the reference variable) that determines which version of an overridden method will be executed.
. type of refrence var is of parent and implimentation(object creation) is of child.
. if a superclass contains a method that is overridden by a subclass, then when different types of objects are referred to through a superclass reference variable, different versions of the method are executed.


Final keyword
. final variable is a constant // i.e cannot be changed final int a=4;(will show error if try to change value of a (a=2 error)).
. final class stops inheritance // i.e final class cannot have child class.
. final method to stop method overriding.


Object class equals tostring hashcode
. Object class is parent class of all the classes.
. if we print object's ref var it gives classname@hashcode i.e. it calls toString mthd from object class.
. can generate own toString and equals mthd with the help of IDE.
. equals method compares referance by default if want to change logic then override the equals mthd.
Up and down Casting - reference of parent obj of child down cast to create refrence of child.
e.g. 	A obj=new B();  //upcasting		double a = 6.7;
	B obj1=(B) obj; //downcasting		int b = (int) a;


Abstract keyword
. used to just declare a method. (no implimentation of the mthd.)
. abstract method must be in a abstract class.
. we can make a class abstract without any abs mthd // i.e abs mthd is not compulsory to make a abs class but for making abs mthd abs class is compulsory
. if a subclass extends abstract class with abs mthd it must implement/define abstract method. //concrete class-->that implements all the mthds.
. we cannot make object of abstract class. // can make reference of abs class but obj must be of subclass(concrete class).Dynamic mthd dispatch
. if we don't want to define all the mthds in child class then make the child class abstract and make a grandchild class which will define the mthd and then the obj will be created of that grandchild class.
. if don't want another class to define abs mthd, create obj of abs class with abs mthd defined in anonymous inner class.

abstarct class A{
	public abstract void one();
}
	A obj = new A(){		// in main mthd.
	public void one()
	syso("in one");
	};
	obj.one();
}


Inner Class (nested class)
. class in a class
. to call mthd and variable of inner class, create object obj of A then A.B obj1=obj.new B();      obj1.mthdname; 	//need object of outer class to create object of inner class.
. if inner class is static then A.B obj1=new A.B();
. outer class cannot be static but inner class can be static. outer class can be public,abstract,final.			//can have only one public class per file. **
. class name $ innercalss name.class
... anonymous inner class.		// class name $ 1.class  (class name is in which anon inner class is defined while creating obj.)
... abstract and anonymous inner class.  instead of making new class to define abs mthd define in anon inner class.


Interface 	//loose coupling
. not a class, every method by default public abstract.		//only declares mthd does not define.
. mthds can be static, abstract, default (*has body inside the interface only.)
. every variable by default final and static.		//interface does not have heap memory therefore final.
. therefore variables must be defined in interface itself and called using interface name(because static).
. class impliments a interface and therefore must define all mthds(which are abs by default) in the class.
. a class can impliment multiple interfaces at a time.
. interface extends another interface.
. to instantiate interface - impliment class make obj or inner class. 
. *funtional interface - has only 1 mthd    SAM- single abstract method
. marker interface?? has no mthds/blank interface. used to update something to the compiler. eg. serializable, runnable  (in serialization can store values of an object in hardrive.)
. a game has checkpoint/savegame, this is serialization and when game starts again its deserialization.



enum(gfg) see eg. (named constants )	//Like in http status 200 OK is a status
. enum extends enum class.				enum Status{
. enum constants are objectss. eg. 	----->	---->	   Running,Failed,Success;}
. can't inherit or extend. 				Status s = Status.Success; 	//in main class
. using switch makes more sense for enums.		   syso(s);			//will print Success.
. enum name.value give array of all constants.		eg. Status.values
. can use private constructors. 	see vid eg....

bug is logical issue
annotations give extra info to compiler


Lambda exp
. works with functional interface.		see eg.
. lambda function is used to implement functional interface.(func intefce eg. Runnable, Callable, Comparable.
. func interface can be implemented 1.using a class which implements the FI and then creating obj of class to use mthd.//FI f1=new ClassimplenFI
				    2.by creating anon inner class of FI. // FI f1=new FI(){FI mthd(){code}}
				    3.by using Lambda func. FI f1 = ()->code;
. used to decrease the lines of code.
. has no name, modifeir, return type.
. if the body of lambda exp. has only one line then curly braces are optional. return is optional if that is the only piece of code; compiler intelligent.
. writing the type of variable is optional. (int a,int b)->{returna+b;}// can be written as (a,b)->a+b;
. does not create seperate anon.class file after compiling if usiing Lambda exp.

Exceptions									|-> extends object
. Error -> compile time error(syntax easy), run time error, logical error. 		Exception extends throwable  impliments serializable
. compile time errors - ide usually shows error, syntactical errors(eg typo) easy to solve.
. logical errors - expected outcome is not coming.
. run time errors - these are exceptions which stops the execution and need to be handeled.
. execution stops when an exception occures.
. Hirarchy => Object class -> Throwable calss -> 1) Error class and 2) Exception class.
. Errors stop the execution -> caused by-Thread death, I/O error, VM error, Out of memory.	//cannot be handeled.
. write critical statement in try block.	statement that can cause exception
. try block will try to execute critical statement, if exception occures cath block will execute.
. compiler throws object(exception), so - catch(Exception e);   Excetion class.(parent class)
. catch block executed only if there is an exception.
. write parent class exception in the last catch block.
. runtime exp are unchecked(eg array index, dev by 0, null pt.) compile time are checked(sql,i/o). 
. depends on user if they choose to handle the checked exception. compiler will force to handle unchecked exception.
. throw used to throw an exception logically.	used to propogate unchecked exceptions  	see img
. creating an exception of ur own.
. ducking exception throws keyword - throws excp to the mthd which is calling critical mthd.  used to propogate checked excs
. method calling critical mthd(which throws) must have try catch at mthd call.
. finally will execute even if there is an exception or not.    // used to close resources. try-catch-finally, try-finally.
. e.printStackTree

SEE_CODE
Threads		(multiple things happening at the same time using multiple threads)(improve cpu utilization.)*(threads are the smallest unit one can work with.)*
. The concept of threads in Java was introduced to address the limitation of running only one task at a time. Threads allow a program to operate more efficiently by 	 
  running multiple tasks simultaneously.
. s/w -> runs on OS -> is on h/w where CPU does the processing(i.e. executes) and ram holds the memory temporarily for processing.
. jvm will execute line by line, if want two process(or different mthd calls) to execute parallelly then use threads.
. a class extends thread class or impliments runnable.(if implimented then threadobj.start() does not work,runnable does not have start mthd see img.)
. class extending thread must have a run method. Then after object creation threadobj.start in the main mthd.
. create obj of class extending thread class then to call mthd threadobj.start();
. OS Schedular will schedule the proccess, it's job is which thread to execute.
. Thread.sleep (thread will go in waiting stage, 	in milliseconds), Thread.setpriority. to set priority.
. if class wants to extend other class it cannot because multiple inheritance not suppported,so use runnable interface instead.
	see desktop eg. impliment runnable. * see code
. can use lambda exp as runnable is functional interface.
. threadobj.join -> waits for thread to die(complete it' execution) and then the other execution will run.
. Race condition -> two or more threads working on same variable or method.(synchronized keyword, volatile keyword, atomic, transient.)
. synchronized used for mthds. volatile used for variables.	**Check something to do with main memory and cached memory..**

* There may be a chance of data inconsistency problem to overcome this problem we should go for a synchronized keyword when multiple threads are
 trying to operate simultaneously on the same java object. If a method or block declares as synchronized then at a time only one thread at a time
 is allowed to execute that method or block on the given object so that the data inconsistence problem will be resolved.

* If a value of a variable keeps on changing by multiple threads then there may be a chance of a data inconsistency problem. It is a modifier applicable
 only for variables, and we can’t apply it anywhere else. We can solve this problem by using a volatile modifier. If a variable is declared as volatile 
 as for every thread JVM will create a separate local copy. Every modification performed by the thread will take place in the local copy so that there is 
 no effect on the remaining threads.
												stop()
										   |--------------->Dead
 . Thread states -> New -> Runnable -> Running -> Waiting ------> runnable -> CYCLE_REPEAT.
					  start()     run()  sleep(),wait()		notifiy()

. User Thread- JVM wait until user threads to finish their work. It never exit until all user threads finish their work. all threads by default user thread as daemonThread.setDaemon(false) by default.
. Daemon Thread- The JVM will not wait for daemon threads to finish their work. The JVM will exit as soon as all user threads finish their work. to make a thread daemon thread .setDaemon(true). Daemon thread is a thread that runs in the background and is designed to provide services or perform tasks like garbage collection, event handling.

					  

Collections (uses wrapper class)// framework is set of classes and interface which provide ready made arch.
. collection API, Collection interface, Collections class.   /API lib or feature we simply use don't have to impliment
. Collection a = new ArrayList(); //Collection interface, Arraylist implimets List interface which extends Collection interface. a.add.           (but is immutable)
. List<Integer> a = new ArrayList<Integer>();
. a.add(1); 		  or can use List<Integer> b = List.of(1,2,3); instead of first defining and the using .add();.
. List takes input in sequence and supports repetitive values. has a get mthd for the index no. *Set is not indexed so no get mthd.
. Collection/Set<Integer> a = new HashSet<Integer>();
. Set will not give the repetitive value. output is not in sequence. does not have get mthd for index no.
. if want sorted output use TreeSet instead of HashSet. Set->HashSet->LinkedHashSet(output in sequence.) or...
. Or Set->SortedSet(interface)->TreeSet(sorted output.) impl in binary search tree.   *See collection hirar.. 
. collection interface extends iterable which has mthd iterator. used to print values. can use for-each loop,foreach() method.

Iterator<Integer>b = a.iterator();
        while(b.hasNext()){
            System.out.println(b.next());
        }

. Map does not extend or implement collection interface. it is an interface of its own. part of collection api
. map is collection of key and value pair. instead of index no. we use key. (to get value i.e. mapObject.get(key);)
. in map key is distinctive and value can be repetitve.
. output is not in sequence.
. Use TreeMap if want sorted (sorted on the bases of keys.) 
. keys are set, values are list.
. Hashmap data stored in buckets(intially 16 index 0-15) in nodes(hash|key|value|address of next) as linkedlist.
. index automatically increases after reaching 12.
. can use hashmap or hashtable, only difference is hashtable is synchronized i.e thread safe, hash map can have 1 null key and mutiple null values
  whereas hashtable cannot have null key or value. null key in hashmap will inserted in the 0 index of the bucket. 
. can search element in O(1) time complexity using hash map. (Time complexity BST -> O(log n)) 
. Hashing in Java is a technique for mapping data to a secret key that can be used as a unique identifier for data. It employs a function that 
  generates those keys from the data; this function is known as the Hash-function, and the output of this function (keys) is known as Hash-values.
  Hashing is the practice of transforming a given key or string of characters into another value.
. given a key of strings hashcode changes it to a no. and hashing optimizes no. (hascode creates big no. and hashing reduces that no.)
. separate chaining is best to handle collisions. 
. collision saved by 1. chaining(linked list) 2. open addressing (Collision is when more than one key has same hash value)(while searching.)
. if threshhold of linkedlist chaining is crossed(i.e complexity increasing) then bst is used instead.
. suppose multiple keys(k) with same hascode(at index 4) then index 4 will contain k1 - k2 - k3 - k4 in same index using linkedlist.
. comporator vs comparable. (used for sorting) can implement your own logic for sorting. Functional interfaces?? comparator is but comparable????
. Comparator has a method compare and comparable has a method compareTo.
. Comparator is from java.util and comparable is from java.lang package.

	Comparator<Object> comp = new Comparator<Object>(){
		int compare(Object i, Object j){
			//logic eg:-
			if(i>j){
			return 1; (returning 1 will swap the no.s)
			}
			else
				return -1;
		}
	};
			Collections.sort(list object(Or user defined object),comp);


Stream
. Streams are related to collection framework. introduced in 1.8.
. used to perform bulk operations and process objects of collections. reduce the code length.
. stream can be applied on collections as well as on grp of objects(eg. Arrays.stream())
. mthds filter(predicator), map, foreach etc...
. can be used only once.

. ArrayList vs LinkedList (image in this repo.)
Both implement the List interface

Use ArrayList when:
You need fast random access.
Insertions/removals are mostly at the end.
Memory usage is a concern.

Use LinkedList when:
You have lots of insertions/deletions in the middle/start.
You don't need fast random access.
You’re using iterators for modification.

. Optional -> is a container object used to represent the presence or absence of a value. It was introduced in Java 8 to help avoid NullPointerException and make code more expressive and safer.

. Java 8 features:															|-> list.foreach(System.out::println) instead of list.forEach(s -> System.out.println(s));
 Lambda exp, Functional interface, Stream API, Default mthd in interfces, mthd references, OPtional class, Date Time API, Collectors.

@Value- used for injecting values into fields, methods, or constructor parameters. It is part of Spring's dependency injection (DI) mechanism and allows you to inject values from properties files, environment variables, or other sources directly into your Spring-managed beans.

Spring-managed beans are at the heart of Spring’s IoC container. They are objects that Spring manages throughout their lifecycle, including instantiation, dependency injection, and destruction. By using Spring-managed beans, you can achieve loose coupling, improved modularity, and greater flexibility in your applications.
Annotation-based Configuration 
    @Component: A generic annotation for any Spring bean.
    @Service: A specialization of @Component, typically used for service layer beans.
    @Repository: A specialization of @Component, used for DAO (data access) layer beans.
    @Controller: A specialization of @Component, used for Spring MVC controllers.

You don't manually create the object using new in your code. Instead, you declare the bean, and Spring takes care of its creation, configuration, and dependencies.
@Bean-  The @Bean annotation tells Spring that the method will return an object that should be managed as a Spring bean and that Spring should take care of creating and managing the lifecycle of that object. The @Bean annotation is typically used within a @Configuration class.

volatile
transient
synchronized
@Builder

 


regex
 

