## J
. Programming languages -> 1. Functional 2.Procedural 3.OOP
. Static and Dynamic typed languages.
. In Static Typing, type checking is performed during compile time. It means that the type of a variable is known at compile time.(java,C,C++)
. In Dynamic Typing, type checking is performed at runtime. For example, Python is a dynamically typed language. It means that the type of a variable is allowed to change over its lifetime.(python, php, js, Ruby).
. java works on unicode languages supports every regional language.
. instance var,obj-- in heap memory, local var,ref var-- in stack memory.
. var in stack memory and each obj in heap memory with address. memory in jvm. main stack, new mthd dd- dd stack memory.
. 


. platform indipendent - run application on any machine irrespective of h/w or OS but machine must have jvm.
			app is indipendent but jvm is dependent every os has its own jvm.
			jvm looks for the main method to start the execution.(execution starts from the main method.)
. Programmer writes Java code(Source code .java file), which is compiled(using javac compiler) to Byte code(.class file) which is understood by the JVM.


. h/w->os->jdk(->jre(->jvm))
. code will run on jvm, jre has required libs to run the code.(inbuilt libs classes used in the code.) also validate the byte code, class loader.
. Compile code with jdk and run on jvm. jre has necessary lib,fles, class req to run byte code

. The Just-In-Time (JIT) compiler is a component of the runtime environment that improves the performance of Java applications     by compiling bytecodes to native machine code at run time.

. java is compiler-interpreter lang. .java file is compiled/transformed using the javac compiler into the bytecode which is understood by the jvm. The jvm then interprets this bytecode and converts it into the machine code which can be understood by the computers h/w.

. The source code we write in Java is first compiled into bytecode during the build process. The JVM then interprets the generated bytecode for execution. However, the JVM also makes use of a JIT compiler during runtime to improve performances.

. var is a reserved type name, detects variable data type automatically.

. java is strongly typed lang.
. In java there is no pass by referance, there is only pass by value.
. Shadowing in java.
. Declaration at compile time and initilisation at run time(i.e obj in heap) int a(at compile time)=10;(at run time) -> Dynamic memory allocation.

. Enhanced for loop for arrays.

. reference var/obj ref.	 Calculator(type) c(ref var) = new Calculator() 

. public -> accessible everywhere in the project.
  private -> accessible in the same class, no one from outside world can access the data directly.
  default -> accessible in the same package.//i.e acc in same class, package subclass, package non-subclass.
  protected -> acc in same package and subclass of diff package.// acc in same class, package subclass, package non-subclass, diff package subclass.

. class public, instance var private, mthd public. rest requirement based. avoid default.
. varargs ambiguity while mthd overloading. //compiler cannot decide which mthd to call.

Method overloading
. same mthd name different parameters. either parameter length or type should be different. 

Stack and heap memory in jvm
. stack lifo and heap open space expandable.
. every mthd has its own stack.


* SOLID Principles Java
. In Java, SOLID principles are an object-oriented approach that are applied to software structure design.  It also ensures that the software is modular, easy to 
  understand, debug, and refactor.
. The word SOLID acronym for:
	|-> Single Responsibility Principle (SRP) -> The single responsibility principle states that every Java class must perform a single functionality.

	|-> Open-Closed Principle(OCP) -> The open-closed principle states that according to new requirements the module should be open for extension but closed 							formodification.
	|-> Liskov Substitution Principle (LSP) -> It applies to inheritance in such a way that the derived classes must be completely substitutable for their base classes.

	|-> Interface Segregation Principle (ISP) -> The principle states that the larger interfaces split into smaller ones. Because the implementation classes use only 						     the methods that are required.
	|-> Dependency Inversion Principle (DIP) -> The principle states that we must use abstraction (abstract classes and interfaces) instead of concrete implementations.



* How function calls work.
. while the function has not stopped executing it will remain in the stack.
. when a function finishes execution it is removed from the stack and the flo3w of the program is restored to where it was called.
. main function is the last function to be removed from the stack. (and first to be added.)
https://www.youtube.com/watch?v=M2uO2nMT0Bk&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=23


* Recursion
. method calling itself.
. if you are calling a function again and again you can treat as an separate call in the stack.
. Base condition is the condition where our recursion will stop making new calls. (simole if condition.)
. Helps in solving big/complex problems easily.
. recursion tree is the flow of the mthd calls.
. last function call is called tail recursion.


* Array objects are in heap and heap objects are not continuous due to dynamic memory allocation. So in java it is not compulsory always that memory allocation done in continuous sequence it is depend on J.V.M.



Arrays								  datatype ref.var.=object;
. arrays are objects, can hold multiple values of same data type. int a[]={1,2,3}; or int a[] = new int[3]; a[0]=1;
. multidimetional array is array of arrays. int a[][] = new int[3][4]; to assign random values a[i][j] = (int)(Math.random()*10);
. 2 for loops 1 for row and other for column.
. enhanced for loop. no need of array length. for(int n[]:a){for(int m:n){syso(m);}sysoln(" ");}  
. jagged array int a[][] = new int[3][];				for(int i=0;i<a.length;i++){		FOR JAGGED ARRAY.
		a[0]=new int[3]; defining column size.				for(int j=0;j<a[i].length;j++{
		a[1]=new int[2];							Syso(a[i][j]);}
		a[2]=new int[4];						Sysoln("");}
. drawback size fixed, will traverse the array to find element time consuming.
. Array of objects. Student stud[] = new Student[3];			Student s1=new Student();
			stud[0]=s1(ref var of Student)			s1.rollno=3;
. In ArrayList initially size is fixed but when limit reaches, it copies the elements to new list with increased size and deletes the prev. list.

** Command line arguments in java  (String[] args);



== vs .equals. (== is a comparator)
. == operator to check memory location or address of two objects are the same or not.
. == checks if both objects point to the same memory location whereas .equals() evaluates to the comparison of values in the objects.



String									   Datatype  ref.var. = object;		|  b |	--------(---	)    point to same object in string
. String is a class in java. String s=new String("abc"); syso(s);		* String a = "Rana";		|  a | ---------( "Rana")    pool in heap memory.	
. String has different mthds s.charAt,						* String b = "Rana"		|____|		(	)
														stack		   heap
. If 2 strings have same content(value) they get same address in string constant pool. strings are immutable. 			
. String pool is separate memory structure in the heap memory(created for optimisation) if n no. of ref var have same value, they point to one obj.
. If we change something in the existing string, it creates new constant.
. Can create diffrent string objects with same value using 'new' explicitly. The object will be created in the heap memory outside string pool.
e.g.    String a="ab"; address 101  constant, immutable
	a=a+"cd";	address 102
Syso()		println -> is of type printStream -> has mthd valueOf -> which uses toString.	****//CHECK.
 . pretty printing in java using printf.
eg :- System.out.prinf("My name is %s and i am %s", "Abcd", "happy."); output -> My name is Abcd and iam happy. 	//format specifier.
. if printing an object it will call toString().
. + operator works for primitives and in an expression atleat in eshould be an string (new ArrayList<>() + "" + new Integer(21)) output -> []21  //without string("") error.




String s
. s.split(regex) -split in array- if regex =" " , split after every space.
. s.trim()  removes starting and ending spaces.
. s.replaceAll(regex,replacement)
. s.replace()
. .comparesTo--- if s1>s2 +ve val,s1==s2 0,s1<s2 -ve value; 
.valueOf  int to string.
. Strings are immutable, string constant pool
String, buffer, builder.
. StringBuffer is a class in Java that represents a mutable sequence of characters. It provides an alternative to the immutable String class, allowing you to modify the contents of a string without creating a new object every time.
StringBuffer is thread safe and StringBuilder is not.



StringBuilder sb
. sb.charAt
. sb.setCharAt
. sb.insert
. sb.delete
. sb.append
. sb.length
. sb.replace
. sb.reverse
. sb.toString


Static		//no need to create obj of class to use the static variable, can be called using classname psvm()
. static variable makes the variable common to all the objs i.e static var is shared by all the objs.
. static var/mthd should be called with the class names instead of the objs.
. dont need object of class to call static mthd.
. The main() method is static so that JVM can invoke it without instantiating the class.
. static makes something a class member not obj member.
. can use static variable in a non static mthd.
// not neccess. static method can only call a static method. in same class.
. static block used to initialise the static variables.
. static block is called only once irrespective of how many objs are created.
. class loads and then obj is instantiated, and class loads only once (via class loader).every time class loads it will call static block.
. static block call---> then const.(if no obj creation then class don't load, then to call static block Class.forName(className))
. cannot access non static var in a static method but can access static var in static method and non static mthd.
	each object has its own value. obj.name="abc"; obj1.name="def"; 
. can use non static var by passing the obj itself in the static method. (which obj value u want to show Classname.statmthd(obj1))

kamal aujila.

Encapsulation
. binding of data with methods. getter setter. 


This Keyword
. The this keyword refers to the current object in a method or constructor which is callig the mthd.

public void setName(String name){
		this.name=name;}
obj.setName("we");	//in main mthd.

. priority given to the local var
. private name;
. public void setName(String name){
. this.name=name; // this.name is instance var and name is local variable. bts classname obj1=obj(obj passed in mthd); /n obj1.name=name;


Constructors
. same name as that of a class, has no return type.
. Can give default values to variables. //otherwise default values are 0, null.
. called when an obj is created. // default constuctor, parameterised const.
. super()--execute the const of super class. john cena cant see it its there.(inheritance) create obj of subclass, constructor of super class will also be called.
. this()--execute the const of same class.
..singleton class. class which can have only one global object.


Anonymous obj
. has no refrence var. // new ClassName(); will call const only, new ClassName().methodname(); will call mthd also, can't be used again.
. has no name.


Inheritance
. single level multi level inheritance // parent/super/base class  child/sub/derived class
. java does not support multiple inheritance //ambiguity
. when we create a Child class object and call the function a(), the compiler gets confused about whether to call the a() method of Parent1 or Parent2. This is the ambiguity problem faced by the compiler hence multiple inheritance is not supported in Java.
. every class which does not extends, extends the Object class by default


Method Overriding
. same name method in subclass can override method in the parent class.
. private, static, final methods cannot be overriden. (static -> method hiding, hides superclass mthd.)

packages
. import class which is in different package.
. java.lang package imported by default. when we use system,string etc it is from java.lang package 


Polymorhism (many forms/behaviour)
. Compile time polymorhism (early binding) -->mthd overloading // behaviour defined at compile time. static polymorphism.
. Run time polymorhism (late binding) -->mthd overriding , dynamic method dispatch(refrence of parent and obj of child).jvm Dynamic polymorphism


WRAPPER class (to make entirely object oriented)
. java is not entirely Object oriented. because of primitive data types don't extend obj class.
. for every primitive type we have a class which is used in certain frameworks.
. storing primitive variable in wrapper class object is called autoboxing. int a=4; Integer b=a;	//Autoboxing.
. integer b=a; int c =b; //auto-unboxing  or int c= b.intValue(); //unboxing.


Dynamic Method Dispatch (impliments run time polymorphism)
. at run-time, it depends on the type of the object being referred to (not the type of the reference variable) that determines which version of an overridden method will be executed.
. type of refrence var is of parent and implimentation(object creation) is of child.
. if a superclass contains a method that is overridden by a subclass, then when different types of objects are referred to through a superclass reference variable, different versions of the method are executed.


Final keyword
. final variable is a constant // i.e cannot be changed final int a=4;(will show error if try to change value of a (a=2 error)).
. final class stops inheritance // i.e final class cannot have child class.
. final method to stop method overriding.


Object class equals tostring hashcode
. Object class is parent class of all the classes.
. if we print ref, var it gives classname@hashcode i.e. it calls toString mthd from object class.
. can generate own toString and equals mthd with the help of IDE.
. equals method compares referance by default if want to change logic then override the equals mthd.
Up and down Casting - reference of parent obj of child down cast to create refrence of child.
e.g. 	A obj=new B();  //upcasting		double a = 6.7;
	B obj1=(B) obj; //downcasting		int b = (int) a;


Abstract keyword
. used to just declare a method. (no implimentation of the mthd.)
. abstract method must be in a abstract class.
. we can make a class abstract without any abs mthd // i.e abs mthd is not compulsory to make a abs class but for making abs mthd abs class is compulsory
. if a subclass extends abstract class with abs mthd it must implement/define abstract method. //concrete class-->that implements all the mthds.
. we cannot make object of abstract class. // can make reference of abs class but obj must be of subclass(concrete class).Dynamic mthd dispatch
. if we don't want to define all the mthds in child class then make the child class abstract and make a grandchild class which will define the mthd and then the obj will be created of that grandchild class.
. if don't want another class to define abs mthd, create obj of abs class with abs mthd defined in anonymous inner class.

abstarct class A{
	public abstract void one();
}
	A obj = new A(){		// in main mthd.
	public void one()
	syso("in one");
	};
	obj.one();
}


Inner Class (nested class)
. class in a class
. to call mthd and vrbl of inner class, create object obj of A then A.B obj1=obj.new B();      obj1.mthdname;
. if inner class is static then A.B obj1=new A.B();
. outer class cannot be static but inner class can be static. outer class can be public,abstract,final.
. class name $ innercalss name.class
... anonymous inner class.		// class name $ 1.class  (class name is in which anon inner class is defined while creating obj.)
... abstract and anonymous inner class.  instead of making new class to define abs mthd define in anon inner class.


Interface 	//loose coupling
. not a class, every method by default public abstract.		//only declares mthd does not define.
. mthds can be static, abstract, default (*has body inside the interface only.)
. every variable by default final and static.		//interface does not have heap memory therefore final.
. therefore variables must be defined in interface itself and called using interface name(because static).
. class impliments a interface and therefore must define all mthds(which are abs by default) in the class.
. a class can impliment multiple interfaces at a time.
. interface extends another interface.
. to instantiate interface - impliment class make obj or inner class. 
. funtional interface - has only 1 mthd    SAM- single abstract method
. marker interface?? has no mthds/blank interface. used to update something to the compiler. eg. serializable, runnable
. a game has checkpoint/savegame, this is serialization and when game starts again its deserialization.



enum(gfg) see eg. (named constants )
. enum extends enum class.		enum Status{
. enum constants are objs.			Running,Failed,Success;}
. can't inherit or extend. 			Status s = Status.Success; 	syso(s);

bug is logical issue
annotations give extra info to compiler


Lambda exp
. works with functional interface.		see eg.
. lambda function is used to implement functional interface.(func intefce eg. Runnable, Callable, Comparable.
. func interface can be implemented 1.using a class which implements the FI and then creating obj of class to use mthd.//FI f1=new ClassimplenFI
				    2.by creating anon inner class of FI. // FI f1=new FI(){FI mthd(){code}}
				    3.by using Lambda func. FI f1 = ()->code;
. used to decrease the line of code.
. has no name, modifeir, return type.
. if the body of lambda exp. has only one line then curly braces are optional. retrn is optional; compiler intelligent.
. writing the type of variable is optional. (int a,int b)->{returna+b;}// can be written as (a,b)->a+b;

Exceptions									|-> extends object
. Error -compile time(syntax easy), run time, logical. 		Exception extends throwable ??impliments serializable??
. execution stops when an exception occures.
. write critical statement in try block.	statement that can cause exception
. try block will try to execute critical statement, if exception occures cath block will execute.
. compiler throws object(exception), so - catch(excepion e);   excetion class.
. catch block executed only if there is an excetion.
. write parent class exception in the last catch block.
. runtime exp are unchecked(eg array index, dev by 0, null pt.) compile time are checked(sql,i/o). 
. depends on user if they choose to handle the checked exception. compiler will force to handle unchecked exception.
. throw used to throw an exception logically.	used to propogate unchecked exceptions  	see img
. creating an exception of ur own.
. ducking exception throws keyword - throws excp to the mthd which is calling critical mthd.  used to propogate checked excs
. method calling critical mthd(which throws) must have try catch at mthd call.
. finally will execute even if there is an exception or not.    // used to close resources. try-catch-finally, try-finally.
. e.printStackTree

Threads		(multiple things happening at the same time using multiple threads)(improve cpu utilization.)*(threads are the smallest unit one can work with.)*
. The concept of threads in Java was introduced to address the limitation of running only one task at a time. Threads allow a program to operate more efficiently by 	 
  running multiple tasks simultaneously.
. s/w -> runs on OS -> is on h/w where CPU does the processing(i.e. executes) and ram holds the memory temporarily for processing.
. jvm will execute line by line, if want two process(or different mthd calls) to execute parallelly then use threads.
. a class extends thread class or impliments runnable.(if implimented then obj.start() does not work,runnable does not have start mthd see img.)
. class extending thread must have a run method. Then after object creation obj.start in the main mthd.
. create obj of class extending thread class then to call mthd obj.start();
. OS Schedular will schedule the proccess, it's job is which thread to execute.
. thread.sleep (thread will go in waiting stage, 	in milliseconds), thead.setpriority. 
. if class wants to extend other class it cannot because multiple inheritance not suppported,so use runnable interface instead.
	see desktop eg. impliment runnable.
. can use lambda exp as runnable is functional interface


Collections (uses wrapper class)// framework is set of classes and interface which provide ready made arch.
. collection API, Collection interface, Collections class.   /API lib or feature we simply use don't have to impliment
. Collection a = new ArrayList(); //Collection interface, Arraylist implimets List interface which extends Collection interface. a.add.           (but is immutable)
. List<Integer> a = new ArrayList<Integer>();
. a.add(1); 		  or can use List<Integer> b = List.of(1,2,3); instead of first defining and the using .add();.
. List supports repetitive values. has a get mthd for the index no. *Set is not indexed so no get mthd.
. Collection/Set<Integer> a = new HashSet<Integer>();
. Set will not give the repetitive value. output is not in sequence. does not have get mthd for index no.
. if want sorted output use TreeSet instead of HashSet. Set->HashSet->LinkedHashSet(output in sequence.) or...
. Or Set->SortedSet(interface)->TreeSet(sorted output.) impl in binary search tree.   *See collection hirar.. 
. collection interface extends iterable which has mthd iterator. used to print values. can use for-each loop,foreach() method.

Iterator<Integer>b = a.iterator();
        while(b.hasNext()){
            System.out.println(b.next());
        }

. Map does not extend or implement collection interface. it is an interface of its own. part of collection api
. map is collection of key and value pair. instead of index no. we use key. (to get i.e. mapObject.get(key);)
. in map key is distinctive and vaule can be repetitve.
. output is not in sequence.
. Use TreeMap if want sorted (sorted on the bases od keys.) 
. keys are set, values are list.
. can use hashmap or hashtable, only difference is hashtable is synchronized.
. comporator vs comparable. (used for sorting) can implement your own logic for sorting. Functional interfaces?? comparator is but comparable????
. Comparator has a method compare and comparable has a method compareTo.
. Comparator is from java.util and comparable is from java.lang package.

	Comparator<Object> comp = new Comparator<Object>(){
		int compare(Object i, Object j){
			//logic eg:-
			if(i>j){
			return 1; (returning 1 will swap the no.s)
			}
			else
				return -1;
		}
	};
			Collections.sort(list object(Or user defined object),comp);


Stream
. Streams are related to collection framework. introduced in 1.8.
. used to perform bulk operations and process objects of collections. reduce the code length.
. stream can be applied on collections as well as on grp of objects(eg. Arrays.stream())
. mthds filter(predicator), map, foreach etc...
. can be used only once.
 


regex
 
